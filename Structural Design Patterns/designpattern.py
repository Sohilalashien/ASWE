# -*- coding: utf-8 -*-
"""DesignPattern.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VBIzJE_Q13v2Dq1z99k1rESglumeTq3W
"""

# facsade
class Engine:
    def __init__(self):
        self.speed = 0

    def start(self):
        print("Engine started")
        self.speed = 100

    def stop(self):
        print("Engine stopped")
        self.speed = 0

class Lights:
    def turn_on(self):
        print("Lights on")

    def turn_off(self):
        print("Lights off")

# Facade
class CarFacade:
    def __init__(self):
        self.engine = Engine()
        self.lights = Lights()

    def start_car(self):
        self.lights.turn_on()
        self.engine.start()

    def stop_car(self):
        self.engine.stop()
        self.lights.turn_off()

# Client code
def main():
    car = CarFacade()
    car.start_car()
    # Do something
    car.stop_car()

if __name__ == "__main__":
    main()

class Flyweight:
    def __init__(self, shared_state):
        self.shared_state = shared_state

    def operation(self, unique_state):
        pass

class ConcreteFlyweight(Flyweight):
    def operation(self, unique_state):
        print(f"Shared: {self.shared_state}, Unique: {unique_state}")

class FlyweightFactory:
    def __init__(self):
        self.flyweights = {}

    def get_flyweight(self, shared_state):
        if shared_state not in self.flyweights:
            self.flyweights[shared_state] = ConcreteFlyweight(shared_state)
        return self.flyweights[shared_state]

def main():
    factory = FlyweightFactory()

    flyweight1 = factory.get_flyweight("shared_state_1")
    flyweight1.operation("unique_state_1")

    flyweight2 = factory.get_flyweight("shared_state_1")
    flyweight2.operation("unique_state_2")

    flyweight3 = factory.get_flyweight("shared_state_2")
    flyweight3.operation("unique_state_3")

if __name__ == "__main__":
    main()

from abc import ABC, abstractmethod

# Implementor interface
class DrawingAPI(ABC):
    @abstractmethod
    def draw_circle(self, x, y, radius):
        pass

# Concrete Implementor 1
class DrawingAPI1(DrawingAPI):
    def draw_circle(self, x, y, radius):
        print(f"API1.circle at {x}:{y} radius {radius}")

# Concrete Implementor 2
class DrawingAPI2(DrawingAPI):
    def draw_circle(self, x, y, radius):
        print(f"API2.circle at {x}:{y} radius {radius}")

# Abstraction
class Shape(ABC):
    def __init__(self, drawing_api):
        self.drawing_api = drawing_api

    @abstractmethod
    def draw(self):
        pass

# Refined Abstraction
class CircleShape(Shape):
    def __init__(self, x, y, radius, drawing_api):
        super().__init__(drawing_api)
        self.x = x
        self.y = y
        self.radius = radius

    def draw(self):
        self.drawing_api.draw_circle(self.x, self.y, self.radius)

# Client code
if __name__ == "__main__":
    shapes = [
        CircleShape(1, 2, 3, DrawingAPI1()),
        CircleShape(5, 7, 11, DrawingAPI2())
    ]

    for shape in shapes:
        shape.draw()

from abc import ABC, abstractmethod

# Component interface
class FileSystemComponent(ABC):
    @abstractmethod
    def list_contents(self):
        pass

# Leaf class
class File(FileSystemComponent):
    def __init__(self, name):
        self.name = name

    def list_contents(self):
        print(f"File: {self.name}")

# Composite class
class Directory(FileSystemComponent):
    def __init__(self, name):
        self.name = name
        self.contents = []

    def add(self, component):
        self.contents.append(component)

    def list_contents(self):
        print(f"Directory: {self.name}")
        for component in self.contents:
            component.list_contents()

# Client code
if __name__ == "__main__":
    file1 = File("file1.txt")
    file2 = File("file2.txt")
    file3 = File("file3.txt")

    directory1 = Directory("Folder 1")
    directory1.add(file1)
    directory1.add(file2)

    directory2 = Directory("Folder 2")
    directory2.add(file3)

    root = Directory("Root")
    root.add(directory1)
    root.add(directory2)

    root.list_contents()

# Adaptee class (incompatible interface)
class CelsiusTemperature:
    def get_temperature(self):
        return 25

# Target interface (expected by the client)
class FahrenheitTemperatureInterface:
    def get_temperature(self):
        pass

# Adapter class
class Adapter(FahrenheitTemperatureInterface):
    def __init__(self, celsius_temperature):
        self.celsius_temperature = celsius_temperature

    def get_temperature(self):
        # Convert Celsius to Fahrenheit
        return (self.celsius_temperature.get_temperature() * 9/5) + 32

# Client code
def display_temperature(temperature):
    print(f"Temperature: {temperature.get_temperature()}Â°F")

if __name__ == "__main__":
    celsius_temperature = CelsiusTemperature()
    adapter = Adapter(celsius_temperature)
    display_temperature(adapter)

from abc import ABC, abstractmethod

# Component interface
class Coffee(ABC):
    @abstractmethod
    def cost(self) -> float:
        pass

    @abstractmethod
    def description(self) -> str:
        pass

# Concrete component
class SimpleCoffee(Coffee):
    def cost(self) -> float:
        return 1.0

    def description(self) -> str:
        return "Simple coffee"

# Decorator
class CoffeeDecorator(Coffee):
    def __init__(self, coffee: Coffee):
        self._coffee = coffee

    def cost(self) -> float:
        return self._coffee.cost()

    def description(self) -> str:
        return self._coffee.description()

# Concrete decorators
class Milk(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 0.5

    def description(self) -> str:
        return self._coffee.description() + ", milk"

class Sugar(CoffeeDecorator):
    def cost(self) -> float:
        return self._coffee.cost() + 0.2

    def description(self) -> str:
        return self._coffee.description() + ", sugar"

# Client code
def main():
    coffee = SimpleCoffee()
    print(f"Cost: ${coffee.cost()}, Description: {coffee.description()}")

    coffee_with_milk = Milk(coffee)
    print(f"Cost: ${coffee_with_milk.cost()}, Description: {coffee_with_milk.description()}")

    coffee_with_milk_and_sugar = Sugar(coffee_with_milk)
    print(f"Cost: ${coffee_with_milk_and_sugar.cost()}, Description: {coffee_with_milk_and_sugar.description()}")

if __name__ == "__main__":
    main()

from abc import ABC, abstractmethod

# Subject interface
class Subject(ABC):
    """
    Subject is an interface that both RealSubject and Proxy implement.
    It defines a request method that must be implemented by both classes.
    """
    @abstractmethod
    def request(self) -> None:
        pass

# RealSubject class
class RealSubject(Subject):
    """
    RealSubject is a class that contains the actual implementation of the request method.
    This class performs the core business logic.
    """
    def request(self) -> None:
        print("RealSubject: Handling request.")

# Proxy class
class Proxy(Subject):
    """
    Proxy is a class that acts as a proxy for RealSubject.
    It has a reference to a RealSubject object and controls access to it.
    The request method in Proxy first checks access,
    then delegates the request to the RealSubject if access is allowed.
    """
    def __init__(self, real_subject: RealSubject) -> None:
        self._real_subject = real_subject

    def request(self) -> None:
        """
        The request method of Proxy checks access before delegating the request to the RealSubject
        and logs the access time.
        """
        if self.check_access():
            self._real_subject.request()
            self.log_access()

    def check_access(self) -> bool:
        """
        Check access before allowing the request to be forwarded to the real subject.
        """
        print("Proxy: Checking access prior to firing a real request.")
        return True

    def log_access(self) -> None:
        """
        Log the time of request.
        """
        print("Proxy: Logging the time of request.", end="")

# Client code
def client_code(subject: Subject) -> None:
    """
    The client code demonstrates how the client can work with both RealSubject
    and Proxy objects interchangeably through the Subject interface.
    """
    subject.request()

if __name__ == "__main__":
    print("Client: Executing the client code with a real subject:")
    real_subject = RealSubject()
    client_code(real_subject)

    print("")

    print("Client: Executing the same client code with a proxy:")
    proxy = Proxy(real_subject)
    client_code(proxy)